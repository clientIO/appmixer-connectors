const assert = require('assert');
const sinon = require('sinon');
const testUtils = require('./test-utils');
const commons = require('../../../../src/appmixer/microsoft/dynamics/dynamics-commons');

/** Fixture with all entity variables. */
const fixtureLeadAttributesAll = require('./DynamicEntity/fixture-lead-attributes-all.json');
/** Fixture with attributes available for updating entity. */
const fixtureLeadAttributesUpdate = require('./fixture-lead-attributes-update.json');
/** Fixture with attributes available for creating entity. */
const fixtureLeadAttributesCreate = require('./fixture-lead-attributes-create.json');
const fixtureLeadOptionSets = require('./fixture-lead-optionsets.json');
const fixtureLeadStatusCodes = require('./fixture-lead-statuscodes.json');
const fixtureLeadLookups = require('./fixture-lead-lookups.json');
const fixtureLeadDateTime = require('./fixture-lead-datetime.json');

describe('dynamics-commons', () => {

    const context = testUtils.createMockContext();

    describe('getOutputPortOptions', () => {

        beforeEach(function() {

            sinon.reset();

            // Set properties to generate output port options.
            context.properties = { generateOutputPortOptions: true };
            context.messages = { in: { content: {} } };

            // Stub the HTTP request to return the metadata for Lead entity.
            context.httpRequest.onFirstCall().resolves({
                data: {
                    value: fixtureLeadAttributesAll.value
                }
            });
        });

        describe('outputType = object', () => {

            it('main', async () => {

                context.messages = { in: { content: { outputType: 'object' } } };
                /** Output generated by the action's `sendJson` method. */
                const out = await commons.getOutputPortOptions(context);

                assert.equal(out.length, 235, 'should have 235 items');

                const fieldSubject = out.find((item) => item.label.endsWith('(subject)'));
                assert.equal(fieldSubject.value, 'subject');
                assert.equal(fieldSubject.label, 'Předmět zájmu (subject)');

                const fieldParentAccountId = out.find((item) => item.label.endsWith('(parentaccountid)'));
                assert.equal(fieldParentAccountId.value, '_parentaccountid_value');
                assert.equal(fieldParentAccountId.label, 'Nadřazený obchodní vztah zájemce (parentaccountid)');
            });

            it('should cache the metadata', async function() {

                // First call to staticCache.get should return null. All other calls should return the cached value.
                context.staticCache.get.onFirstCall().resolves(null)
                    .onSecondCall().resolves(42)
                    .onThirdCall().resolves(42);

                await commons.getOutputPortOptions(context);
                assert.equal(context.lock.callCount, 1);
                assert.equal(context.staticCache.get.callCount, 1);
                assert.equal(context.staticCache.set.callCount, 1);

                await commons.getOutputPortOptions(context); // 2nd call should use cache.
                await commons.getOutputPortOptions(context); // 3rd call should use cache.
                assert.equal(context.httpRequest.callCount, 1);
                assert.equal(context.lock.callCount, 3, 'should call lock every time');
                assert.equal(context.staticCache.set.callCount, 1, 'should call staticCache.set only once');
                assert.equal(context.staticCache.get.callCount, 3, 'should call staticCache.get every time');
            });
        });

        describe('outputType = array', () => {

            it('main', async () => {

                context.messages = { in: { content: { outputType: 'array' } } };
                /** Output generated by the action's `sendJson` method. */
                const out = await commons.getOutputPortOptions(context);

                assert.equal(out.length, 1, 'should have 1 item');
                assert.equal(out[0].label, 'Result');
                assert.equal(out[0].value, 'result');

                const schema = out[0].schema;
                assert.equal(schema.type, 'array');
                assert.equal(schema.items.type, 'object');

                const fieldSubject = schema.items.properties['subject'];
                assert.equal(fieldSubject.type, 'string');
                assert.equal(fieldSubject.title, 'Předmět zájmu (subject)');

                const fieldParentAccountId = schema.items.properties['_parentaccountid_value'];
                assert.equal(fieldParentAccountId.type, 'string');
                assert.equal(fieldParentAccountId.title, 'Nadřazený obchodní vztah zájemce (parentaccountid)');

                const fieldNumberOfEmployees = schema.items.properties['numberofemployees'];
                assert.equal(fieldNumberOfEmployees.type, 'number');
                assert.equal(fieldNumberOfEmployees.title, 'Počet zaměstnanců (numberofemployees)');
            });
        });

        describe('outputType = file', () => {

            it('outputType = file', async () => {

                context.messages = { in: { content: { outputType: 'file' } } };
                /** Output generated by the action's `sendJson` method. */
                const out = await commons.getOutputPortOptions(context);

                assert.equal(out.length, 1, 'should have 1 item');
                assert.equal(out[0].label, 'File ID');
                assert.equal(out[0].value, 'fileId');
            });
        });
    });

    describe('generateInspector', () => {

        beforeEach(function() {

            sinon.reset();

            // Set properties to generate output port options.
            context.properties = {
                generateOutputPortOptions: true,
                hideEntitySelection: false,
                objectName: 'lead'
            };
            context.messages = { in: { content: {} } };
        });

        it('cache', async function() {

            context.staticCache.get.onFirstCall().resolves(null);
            setUpdateStubs(context);
            await commons.generateInspector(context, 'IsValidForUpdate');

            const setCacheParamsUpdate = context.staticCache.set.getCall(0).args;
            const cacheKeyUpdate = setCacheParamsUpdate[0];

            // Reset http request history to make `setCreateStubs` work.
            context.httpRequest.resetHistory();
            setCreateStubs(context);
            await commons.generateInspector(context, 'IsValidForCreate');

            const setCacheParamsCreate = context.staticCache.set.getCall(1).args;
            const cacheKeyCreate = setCacheParamsCreate[0];

            assert.notEqual(cacheKeyUpdate, cacheKeyCreate, 'should not use the same cache key for both calls');
            assert.equal(context.staticCache.set.callCount, 2, 'should call staticCache.set for both calls');
        });

        describe('update', () => {

            beforeEach(function() {

                setUpdateStubs(context);
            });

            it('should have ID and objectName field', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.id.type, 'text', 'ID should be text in inspector');
                assert.equal(out.schema.properties.id.type, 'string', 'ID should be string');
                assert.ok(out.schema.required.includes('id'), 'ID should be required');

                assert.equal(out.inputs.objectName.type, 'select', 'should be select in inspector');
                assert.equal(out.schema.properties.objectName.type, 'string', 'objectName should be string');
                assert.ok(out.schema.required.includes('objectName'), 'objectName should be required');
            });

            it('should have ID field and not objectName field', async function() {

                // Hide entity selection when the action is called by another action, eg. UpdateAccount.
                context.properties.hideEntitySelection = true;

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.id.type, 'text', 'ID should be text in inspector');
                assert.equal(out.schema.properties.id.type, 'string', 'ID should be string');
                assert.ok(out.schema.required.includes('id'), 'ID should be required');

                assert.ok(!out.inputs.objectName, 'should not have objectName');
                assert.ok(!out.schema.required.includes('objectName'), 'objectName should not be required');
            });

            // Checking specific fields.
            it('should have fields subject', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.subject.type, 'text', 'should be string');
                assert.equal(out.schema.properties.subject.type, 'string', 'should be string');
            });

            it('should have statuscode field', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.statuscode.type, 'select', 'should be select');
                assert.equal(out.schema.properties.statuscode.type, 'string', 'should be string');
            });

            it('should have custom field new_appmixer_email', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.new_appmixer_email.type, 'text', 'should be string');
                assert.equal(out.schema.properties.new_appmixer_email.type, 'string', 'should be string');
            });

            it('should have boolean field donotfax', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.donotfax.type, 'toggle', 'should be boolean');
                assert.equal(out.schema.properties.donotfax.type, 'boolean', 'should be boolean');
            });

            it('should have DateTime field estimatedclosedate', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs.estimatedclosedate.type, 'date-time', 'should be datetime');
                assert.equal(out.inputs.estimatedclosedate.config.enableTime, false, 'should be date only');
                assert.equal(out.schema.properties.estimatedclosedate.type, 'string', 'should be string');
            });

            it('should not have field entityimage', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.ok(!out.inputs.entityimage, 'should not have entityimage');
                assert.ok(!out.schema.properties.entityimage, 'should not have entityimage');
            });

            it('should not have UUID field leadid', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.leadid, undefined, 'should not have leadid');
                assert.equal(out.schema.properties.leadid, undefined, 'should not have leadid');
            });

            it('should have Lookup field parentaccountid', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(out.inputs['parentaccountid@odata|bind'].type, 'select', 'should be select in inspector');
                assert.deepEqual(out.inputs['parentaccountid@odata|bind'].source, {
                    url: '/component/appmixer/microsoft/dynamics/ListLookupOptions?outPort=out',
                    data: {
                        messages: {
                            'in/targets': ['account'],
                            'in/isSource': true
                        }
                    }
                }, 'should have source in inspector');
                assert.equal(out.schema.properties['parentaccountid@odata|bind'].type, 'string', 'should be string');
            });

            it('should use SchemaName for custom fields not LogicalName', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.ok(out.inputs['msdyn_PredictiveScoreId@odata|bind'], 'Uses SchemaName for custom fields');
                assert.ok(out.schema.properties['msdyn_PredictiveScoreId@odata|bind']);
                assert.equal(out.inputs['msdyn_predictivescoreid@odata|bind'], undefined);
            });

            it('should cache the metadata', async function() {

                // Stub the first set of HTTP requests to return the metadata for Lead entity.
                context.httpRequest
                    .onCall(5).rejects('Dynamics API should not be called! 5')
                    .onCall(6).rejects('Dynamics API should not be called! 6')
                    .onCall(7).rejects('Dynamics API should not be called! 7')
                    .onCall(8).rejects('Dynamics API should not be called! 4');
                context.httpRequest
                    .onCall(9).rejects('Dynamics API should not be called! 9')
                    .onCall(10).rejects('Dynamics API should not be called! 10')
                    .onCall(11).rejects('Dynamics API should not be called! 11')
                    .onCall(12).rejects('Dynamics API should not be called! 8');

                // First call to staticCache.get should return null. All other calls should return the cached value.
                context.staticCache.get.onFirstCall().resolves(null)
                    .onSecondCall().resolves(42)
                    .onThirdCall().resolves(42);

                await commons.generateInspector(context, 'IsValidForUpdate');
                assert.equal(context.lock.callCount, 1);
                assert.equal(context.staticCache.get.callCount, 1);
                assert.equal(context.staticCache.set.callCount, 1);

                await commons.generateInspector(context, 'IsValidForUpdate'); // 2nd call should use cache.
                await commons.generateInspector(context, 'IsValidForUpdate'); // 3rd call should use cache.
                assert.equal(context.httpRequest.callCount, 5);
                assert.equal(context.lock.callCount, 3, 'should call lock every time');
                assert.equal(context.staticCache.set.callCount, 1, 'should call staticCache.set only once');
                assert.equal(context.staticCache.get.callCount, 3, 'should call staticCache.get every time');
            });

            // Generate inspector based on selected entity.
            it('should generate default fields', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                assert.ok(out.inputs['objectName'], 'should have objectName');
                assert.ok(out.inputs['rawJson'], 'should have rawJson');
                assert.ok(out.inputs['json'], 'should have json');
            });

            it('should create inspector for Lead entity', async function() {

                const out = await commons.generateInspector(context, 'IsValidForUpdate');

                // First API call should be to get the metadata for the Lead entity.
                const urlAttributes = context.httpRequest.firstCall.args[0].url;
                assert.match(urlAttributes, /EntityDefinitions\(LogicalName='lead'\)\/Attributes/);
                assert.match(urlAttributes, /SchemaName/, 'should have SchemaName');
                assert.match(urlAttributes, /IsCustomAttribute/, 'should have IsCustomAttribute');
                assert.match(urlAttributes, /filter=IsValidForUpdate/, 'should have IsValidForUpdate in $filter');
                assert.match(urlAttributes, /select=.*IsValidForUpdate,/, 'should have IsValidForUpdate in $select');
                // Second API call should be to get the metadata for all OptionSets.
                assert.match(context.httpRequest.secondCall.args[0].url, /PicklistAttributeMetadata/);

                // Check the inspector fields returned by `sendJson`.
                const groups = Object.keys(out.groups);
                assert.deepEqual(groups, ['main', 'additional', 'address1', 'address2'], 'should have 4 groups');

                // Check schema.
                const schema = out.schema;
                assert.equal(
                    Object.keys(schema.properties).length,
                    // 5 fields are ignored by the action - not sent to the inspector.
                    // 3 fields are added by the action.
                    // ID field added for update
                    fixtureLeadAttributesUpdate.value.length - 5 + 3 + 1,
                    'should have properties'
                );

                // Picklist inputs should have the options.
                fixtureLeadAttributesUpdate.value
                    .filter(item => item.AttributeType === 'Picklist')
                    .map(item => item.LogicalName)
                    .forEach(field => {
                        assert.ok(Array.isArray(out.inputs[field].options), `should have options for ${field}`);
                    });

                // Lookup inputs should have name updated with '@odata|bind'.
                fixtureLeadAttributesUpdate.value
                    .filter(item => item.AttributeType === 'Lookup')
                    .map(item => item.IsCustomAttribute ? item.SchemaName : item.LogicalName)
                    .forEach(field => {
                        assert.ok(out.inputs[field + '@odata|bind'], `should have @odata|bind for ${field}`);
                    });
            });

            it('rawJson', async () => {

                context.properties.rawJson = true;

                const out = await commons.generateInspector(context, 'IsValidForUpdate');
                const inputs = Object.keys(out.inputs);

                assert.equal(inputs.length, 4, 'should have 4 items');
                assert.deepEqual(inputs, ['objectName', 'rawJson', 'json', 'id'], 'should have 4 items');
            });
        });

        describe('create', () => {

            beforeEach(function() {

                setCreateStubs(context);
            });

            it('should have fields subject', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.subject.type, 'text', 'should be string');
                assert.equal(out.schema.properties.subject.type, 'string', 'should be string');
            });

            it('should have statuscode field', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.statuscode.type, 'select', 'should be select');
                assert.equal(out.schema.properties.statuscode.type, 'string', 'should be string');
            });

            it('should have custom field new_appmixerid', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.new_appmixer_email.type, 'text', 'should be string');
                assert.equal(out.schema.properties.new_appmixer_email.type, 'string', 'should be string');
            });

            it('should have boolean field donotfax', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.donotfax.type, 'toggle', 'should be boolean');
                assert.equal(out.schema.properties.donotfax.type, 'boolean', 'should be boolean');
            });

            it('should have DateTime field estimatedclosedate', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.estimatedclosedate.type, 'date-time', 'should be datetime');
                assert.equal(out.inputs.estimatedclosedate.config.enableTime, false, 'should be date only');
                assert.equal(out.schema.properties.estimatedclosedate.type, 'string', 'should be string');
            });

            it('should not have field entityimage', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.ok(!out.inputs.entityimage, 'should not have entityimage');
                assert.ok(!out.schema.properties.entityimage, 'should not have entityimage');
            });

            it('should have UUID field leadid', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs.leadid.type, 'text', 'should be text');
                assert.equal(out.schema.properties.leadid.type, 'string', 'should be string');
            });

            it('should have Lookup field parentaccountid', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(out.inputs['parentaccountid@odata|bind'].type, 'select', 'should be select in inspector');
                assert.deepEqual(out.inputs['parentaccountid@odata|bind'].source, {
                    url: '/component/appmixer/microsoft/dynamics/ListLookupOptions?outPort=out',
                    data: {
                        messages: {
                            'in/targets': ['account'],
                            'in/isSource': true
                        }
                    }
                }, 'should have source in inspector');
                assert.equal(out.schema.properties['parentaccountid@odata|bind'].type, 'string', 'should be string');
            });

            it('should use SchemaName for custom fields not LogicalName', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.ok(out.inputs['msdyn_PredictiveScoreId@odata|bind'], 'Uses SchemaName for custom fields');
                assert.ok(out.schema.properties['msdyn_PredictiveScoreId@odata|bind']);
                assert.equal(out.inputs['msdyn_predictivescoreid@odata|bind'], undefined);
            });

            it('should cache the metadata', async function() {

                // Stub the first set of HTTP requests to return the metadata for Lead entity.
                context.httpRequest
                    .onCall(5).rejects('Dynamics API should not be called! 5')
                    .onCall(6).rejects('Dynamics API should not be called! 6')
                    .onCall(7).rejects('Dynamics API should not be called! 7')
                    .onCall(8).rejects('Dynamics API should not be called! 4');
                context.httpRequest
                    .onCall(9).rejects('Dynamics API should not be called! 9')
                    .onCall(10).rejects('Dynamics API should not be called! 10')
                    .onCall(11).rejects('Dynamics API should not be called! 11')
                    .onCall(12).rejects('Dynamics API should not be called! 8');

                // First call to staticCache.get should return null. All other calls should return the cached value.
                context.staticCache.get.onFirstCall().resolves(null)
                    .onSecondCall().resolves(42)
                    .onThirdCall().resolves(42);

                await commons.generateInspector(context, 'IsValidForCreate');
                assert.equal(context.lock.callCount, 1);
                assert.equal(context.staticCache.get.callCount, 1);
                assert.equal(context.staticCache.set.callCount, 1);

                await commons.generateInspector(context, 'IsValidForCreate'); // 2nd call should use cache.
                await commons.generateInspector(context, 'IsValidForCreate'); // 3rd call should use cache.
                assert.equal(context.httpRequest.callCount, 5);
                assert.equal(context.lock.callCount, 3, 'should call lock every time');
                assert.equal(context.staticCache.set.callCount, 1, 'should call staticCache.set only once');
                assert.equal(context.staticCache.get.callCount, 3, 'should call staticCache.get every time');
            });

            // Generate inspector based on selected entity.
            it('should generate default fields', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                assert.ok(out.inputs['objectName'], 'should have objectName');
                assert.ok(out.inputs['rawJson'], 'should have rawJson');
                assert.ok(out.inputs['json'], 'should have json');
            });

            it('should create inspector for Lead entity', async function() {

                const out = await commons.generateInspector(context, 'IsValidForCreate');

                // First API call should be to get the metadata for the Lead entity.
                const urlAttributes = context.httpRequest.firstCall.args[0].url;
                assert.match(urlAttributes, /EntityDefinitions\(LogicalName='lead'\)\/Attributes/);
                assert.match(urlAttributes, /SchemaName/, 'should have SchemaName');
                assert.match(urlAttributes, /IsCustomAttribute/, 'should have IsCustomAttribute');
                assert.match(urlAttributes, /filter=IsValidForCreate/, 'should have IsValidForCreate in $filter');
                assert.match(urlAttributes, /select=.*IsValidForCreate,/, 'should have IsValidForCreate in $select');
                // Second API call should be to get the metadata for all OptionSets.
                assert.match(context.httpRequest.secondCall.args[0].url, /PicklistAttributeMetadata/);

                // Check the inspector fields returned by `sendJson`.
                const groups = Object.keys(out.groups);
                assert.deepEqual(groups, ['main', 'additional', 'address1', 'address2'], 'should have 4 groups');

                // Check schema.
                const schema = out.schema;
                assert.equal(
                    Object.keys(schema.properties).length,
                    // 5 fields are ignored by the action - not sent to the inspector.
                    // 3 fields are added by the action.
                    fixtureLeadAttributesCreate.value.length - 5 + 3,
                    'should have properties'
                );

                // Picklist inputs should have the options.
                fixtureLeadAttributesUpdate.value
                    .filter(item => item.AttributeType === 'Picklist')
                    .map(item => item.LogicalName)
                    .forEach(field => {
                        assert.ok(Array.isArray(out.inputs[field].options), `should have options for ${field}`);
                    });

                // Lookup inputs should have name updated with '@odata|bind'.
                fixtureLeadAttributesUpdate.value
                    .filter(item => item.AttributeType === 'Lookup')
                    .map(item => item.IsCustomAttribute ? item.SchemaName : item.LogicalName)
                    .forEach(field => {
                        assert.ok(out.inputs[field + '@odata|bind'], `should have @odata|bind for ${field}`);
                    });
            });

            it('rawJson', async () => {

                context.properties.rawJson = true;

                const out = await commons.generateInspector(context, 'IsValidForCreate');
                const inputs = Object.keys(out.inputs);

                assert.equal(inputs.length, 3, 'should have 3 items');
                assert.deepEqual(inputs, ['objectName', 'rawJson', 'json'], 'should have 4 items');
            });

            describe('called by another Create component', function() {

                it('should not have entity selection in the Inspector', async function() {

                    context.properties.hideEntitySelection = true;
                    const out = await commons.generateInspector(context, 'IsValidForCreate');
                    assert.ok(!out.inputs['objectName'], 'should not have objectName');
                });

                it('should not have ID field in the Inspector', async function() {

                    context.properties.hideEntitySelection = true;
                    const out = await commons.generateInspector(context, 'IsValidForCreate');
                    assert.ok(!out.inputs['id'], 'should not have id in inspector');
                    assert.ok(!out.schema.properties['id'], 'should not have id in schema');
                    assert.ok(!out.schema.required.includes('id'), 'should not have id in required fields');
                });
            });
        });
    });
});

function setCreateStubs(context) {

    // Stub the HTTP request to return the metadata for Lead entity.
    context.httpRequest.onFirstCall().resolves({
        data: {
            value: fixtureLeadAttributesCreate.value
        }
    });
    // Stub the second HTTP request to return the metadata for all OptionSets.
    context.httpRequest.onSecondCall().resolves({
        data: {
            value: fixtureLeadOptionSets.value
        }
    });
    // Stub the third HTTP request to return the metadata for StatusCode only.
    context.httpRequest.onThirdCall().resolves({
        data: {
            value: fixtureLeadStatusCodes.value
        }
    });
    // Stub the 4th HTTP request to return the metadata for all Lookups.
    context.httpRequest.onCall(3).resolves({
        data: {
            value: fixtureLeadLookups.value
        }
    });
    // Stub the 5th HTTP request to return the metadata for DateTime only.
    context.httpRequest.onCall(4).resolves({
        data: {
            value: fixtureLeadDateTime.value
        }
    });
}

function setUpdateStubs(context) {

    // Stub the HTTP request to return the metadata for Lead entity.
    context.httpRequest.onFirstCall().resolves({
        data: {
            value: fixtureLeadAttributesUpdate.value
        }
    });
    // Stub the second HTTP request to return the metadata for all OptionSets.
    context.httpRequest.onSecondCall().resolves({
        data: {
            value: fixtureLeadOptionSets.value
        }
    });
    // Stub the third HTTP request to return the metadata for StatusCode only.
    context.httpRequest.onThirdCall().resolves({
        data: {
            value: fixtureLeadStatusCodes.value
        }
    });
    // Stub the 4th HTTP request to return the metadata for all Lookups.
    context.httpRequest.onCall(3).resolves({
        data: {
            value: fixtureLeadLookups.value
        }
    });
    // Stub the 5th HTTP request to return the metadata for DateTime only.
    context.httpRequest.onCall(4).resolves({
        data: {
            value: fixtureLeadDateTime.value
        }
    });
}
